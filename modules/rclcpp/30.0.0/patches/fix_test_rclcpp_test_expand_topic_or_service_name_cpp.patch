diff --git a/rclcpp/test/rclcpp/test_expand_topic_or_service_name.cpp b/rclcpp/test/rclcpp/test_expand_topic_or_service_name.cpp
index 841aa8fd..a3a5cbad 100644
--- a/rclcpp/test/rclcpp/test_expand_topic_or_service_name.cpp
+++ b/rclcpp/test/rclcpp/test_expand_topic_or_service_name.cpp
@@ -96,7 +96,8 @@ MOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(rcutils_allocator_t, !=)
 MOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(rcutils_allocator_t, <)
 MOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(rcutils_allocator_t, >)
 
-TEST(TestExpandTopicOrServiceName, rcutils_string_map_init_fail_bad_alloc) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rcutils_string_map_init_fail_bad_alloc) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcutils_string_map_init, RCUTILS_RET_BAD_ALLOC);
   RCLCPP_EXPECT_THROW_EQ(
@@ -104,7 +105,8 @@ TEST(TestExpandTopicOrServiceName, rcutils_string_map_init_fail_bad_alloc) {
     std::bad_alloc());
 }
 
-TEST(TestExpandTopicOrServiceName, rcutils_string_map_init_fail_other) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rcutils_string_map_init_fail_other) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcutils_string_map_init, RCUTILS_RET_ERROR);
   RCLCPP_EXPECT_THROW_EQ(
@@ -112,7 +114,8 @@ TEST(TestExpandTopicOrServiceName, rcutils_string_map_init_fail_other) {
     std::runtime_error("error not set"));
 }
 
-TEST(TestExpandTopicOrServiceName, rcl_get_default_topic_name_substitution_fail) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rcl_get_default_topic_name_substitution_fail) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcl_get_default_topic_name_substitutions, RCL_RET_ERROR);
   RCLCPP_EXPECT_THROW_EQ(
@@ -120,7 +123,8 @@ TEST(TestExpandTopicOrServiceName, rcl_get_default_topic_name_substitution_fail)
     std::runtime_error("error not set"));
 }
 
-TEST(TestExpandTopicOrServiceName, rcl_get_default_topic_name_substitution_and_map_fini_fail) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rcl_get_default_topic_name_substitution_and_map_fini_fail) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcl_get_default_topic_name_substitutions, RCL_RET_ERROR);
   auto mock2 = mocking_utils::patch_and_return(
@@ -130,7 +134,8 @@ TEST(TestExpandTopicOrServiceName, rcl_get_default_topic_name_substitution_and_m
     std::runtime_error("error not set"));
 }
 
-TEST(TestExpandTopicOrServiceName, rcutils_string_map_fini_fail_bad_alloc) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rcutils_string_map_fini_fail_bad_alloc) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcutils_string_map_fini, RCUTILS_RET_ERROR);
   RCLCPP_EXPECT_THROW_EQ(
@@ -138,7 +143,8 @@ TEST(TestExpandTopicOrServiceName, rcutils_string_map_fini_fail_bad_alloc) {
     std::runtime_error("error not set"));
 }
 
-TEST(TestExpandTopicOrServiceName, rmw_valid_full_topic_name_fail_invalid_argument) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rmw_valid_full_topic_name_fail_invalid_argument) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rmw_validate_full_topic_name, RMW_RET_INVALID_ARGUMENT);
   RCLCPP_EXPECT_THROW_EQ(
@@ -147,7 +153,8 @@ TEST(TestExpandTopicOrServiceName, rmw_valid_full_topic_name_fail_invalid_argume
       RCL_RET_INVALID_ARGUMENT, rcl_get_error_state(), "failed to validate full topic name"));
 }
 
-TEST(TestExpandTopicOrServiceName, rcl_expand_topic_name_fail) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rcl_expand_topic_name_fail) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcl_expand_topic_name, RCL_RET_TOPIC_NAME_INVALID);
   RCLCPP_EXPECT_THROW_EQ(
@@ -155,7 +162,8 @@ TEST(TestExpandTopicOrServiceName, rcl_expand_topic_name_fail) {
     std::runtime_error("topic name unexpectedly valid"));
 }
 
-TEST(TestExpandTopicOrServiceName, rcl_validate_topic_name_fail) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rcl_validate_topic_name_fail) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcl_expand_topic_name, RCL_RET_TOPIC_NAME_INVALID);
   auto mock2 = mocking_utils::patch_and_return(
@@ -166,7 +174,8 @@ TEST(TestExpandTopicOrServiceName, rcl_validate_topic_name_fail) {
       RCL_RET_ERROR, rcl_get_error_state(), "failed to validate full topic name"));
 }
 
-TEST(TestExpandTopicOrServiceName, rmw_validate_node_name_fail_invalid_argument) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rmw_validate_node_name_fail_invalid_argument) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcl_expand_topic_name, RCL_RET_NODE_INVALID_NAME);
   auto mock2 = mocking_utils::patch_and_return(
@@ -177,7 +186,8 @@ TEST(TestExpandTopicOrServiceName, rmw_validate_node_name_fail_invalid_argument)
       RCL_RET_INVALID_ARGUMENT, rcl_get_error_state(), "failed to validate node name"));
 }
 
-TEST(TestExpandTopicOrServiceName, rmw_validate_node_name_fail_other) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rmw_validate_node_name_fail_other) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcl_expand_topic_name, RCL_RET_NODE_INVALID_NAME);
   auto mock2 = mocking_utils::patch_and_return(
@@ -188,7 +198,8 @@ TEST(TestExpandTopicOrServiceName, rmw_validate_node_name_fail_other) {
       RCL_RET_ERROR, rcl_get_error_state(), "failed to validate node name"));
 }
 
-TEST(TestExpandTopicOrServiceName, rmw_validate_namespace_fail_invalid_argument) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rmw_validate_namespace_fail_invalid_argument) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcl_expand_topic_name, RCL_RET_NODE_INVALID_NAMESPACE);
   auto mock2 = mocking_utils::patch_and_return(
@@ -199,7 +210,8 @@ TEST(TestExpandTopicOrServiceName, rmw_validate_namespace_fail_invalid_argument)
       RCL_RET_INVALID_ARGUMENT, rcl_get_error_state(), "failed to validate namespace"));
 }
 
-TEST(TestExpandTopicOrServiceName, rmw_validate_namespace_fail_other) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rmw_validate_namespace_fail_other) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcl_expand_topic_name, RCL_RET_NODE_INVALID_NAMESPACE);
   auto mock2 = mocking_utils::patch_and_return(
@@ -210,7 +222,8 @@ TEST(TestExpandTopicOrServiceName, rmw_validate_namespace_fail_other) {
       RCL_RET_ERROR, rcl_get_error_state(), "failed to validate namespace"));
 }
 
-TEST(TestExpandTopicOrServiceName, rcl_expand_topic_name_fail_other) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rcl_expand_topic_name_fail_other) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcl_expand_topic_name, RCL_RET_ERROR);
   RCLCPP_EXPECT_THROW_EQ(
@@ -218,7 +231,8 @@ TEST(TestExpandTopicOrServiceName, rcl_expand_topic_name_fail_other) {
     rclcpp::exceptions::RCLError(RCL_RET_ERROR, rcl_get_error_state(), "error not set"));
 }
 
-TEST(TestExpandTopicOrServiceName, rcl_expand_topic_name_fail_invalid_node_name) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rcl_expand_topic_name_fail_invalid_node_name) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcl_expand_topic_name, RCL_RET_NODE_INVALID_NAME);
   RCLCPP_EXPECT_THROW_EQ(
@@ -226,7 +240,8 @@ TEST(TestExpandTopicOrServiceName, rcl_expand_topic_name_fail_invalid_node_name)
     std::runtime_error("invalid rcl node name but valid rmw node name"));
 }
 
-TEST(TestExpandTopicOrServiceName, rcl_expand_topic_name_fail_invalid_node_namespace) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rcl_expand_topic_name_fail_invalid_node_namespace) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rcl_expand_topic_name, RCL_RET_NODE_INVALID_NAMESPACE);
   RCLCPP_EXPECT_THROW_EQ(
@@ -234,7 +249,8 @@ TEST(TestExpandTopicOrServiceName, rcl_expand_topic_name_fail_invalid_node_names
     std::runtime_error("invalid rcl namespace but valid rmw namespace"));
 }
 
-TEST(TestExpandTopicOrServiceName, rmw_validate_full_topic_name_fail_other) {
+// TODO(asymingt) enable once mocking works in Bazel.
+TEST(TestExpandTopicOrServiceName, DISABLED_rmw_validate_full_topic_name_fail_other) {
   auto mock = mocking_utils::patch_and_return(
     "lib:rclcpp", rmw_validate_full_topic_name, RMW_RET_ERROR);
   RCLCPP_EXPECT_THROW_EQ(