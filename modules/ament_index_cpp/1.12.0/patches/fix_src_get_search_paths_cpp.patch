diff --git a/ament_index_cpp/src/get_search_paths.cpp b/ament_index_cpp/src/get_search_paths.cpp
index 7a411ac..5c4f59e 100644
--- a/ament_index_cpp/src/get_search_paths.cpp
+++ b/ament_index_cpp/src/get_search_paths.cpp
@@ -15,9 +15,14 @@
 #include "ament_index_cpp/get_search_paths.hpp"
 
 #include <sys/stat.h>
+#include <unistd.h> // For readlink
+#include <limits.h> // For PATH_MAX
 
 #include <cstdlib>
+#include <filesystem>
+#include <iostream>
 #include <list>
+#include <optional>
 #include <sstream>
 #include <stdexcept>
 #include <string>
@@ -26,16 +31,15 @@
 #define stat _stat
 #endif
 
+#include <stdio.h>
+extern char **environ;
+
 namespace ament_index_cpp
 {
 
-std::list<std::string>
-get_search_paths()
-{
+// Try to get the value of an environment variable, and optionally return the result.
+std::optional<std::string> get_env_variable(const char * env_var) {
   char * ament_prefix_path = nullptr;
-  const char * env_var = "AMENT_PREFIX_PATH";
-
-  // get environment variable
 #ifndef _WIN32
   ament_prefix_path = getenv(env_var);
 #else
@@ -43,12 +47,69 @@ get_search_paths()
   _dupenv_s(&ament_prefix_path, &ament_prefix_path_size, env_var);
 #endif
   if (!ament_prefix_path || std::string(ament_prefix_path).empty()) {
-    throw std::runtime_error("Environment variable 'AMENT_PREFIX_PATH' is not set or empty");
+      return {};
+  }
+  return std::string(ament_prefix_path);
+}
+
+// Cross-platform way of obtaining the full path to the current executable. Returns
+// std::nullopt if we can't determine the path.
+static std::optional<std::string>
+get_executable_path()
+{
+#if defined(_WIN32)
+  char result[MAX_PATH + 1] = {'\0'};
+  auto path_len = GetModuleFileNameA(NULL, result, MAX_PATH);
+#elif defined(__APPLE__)
+  char result[MAXPATHLEN + 1] = {'\0'};
+  uint32_t path_len = MAXPATHLEN;
+  if (_NSGetExecutablePath(result, &path_len) != 0) {
+    path_len = readlink(result, result, MAXPATHLEN);
+  }
+#else
+  char result[PATH_MAX + 1] = {'\0'};
+  ssize_t path_len = readlink("/proc/self/exe", result, PATH_MAX);
+#endif
+  if (path_len > 0) {
+    return result;
+  }
+  return std::nullopt;
+}
+
+std::list<std::string>
+get_search_paths()
+{
+  // In a Bazel context AMENT_PREFIX_PATH should not be set.
+  std::optional<std::string> ament_prefix_path = get_env_variable("AMENT_PREFIX_PATH");
+  if (!ament_prefix_path) {
+    
+    // When in a test context both the RUNFILES_DIR and TEST_WORKSPACE environment variables
+    // will be set. So, we can resolve the correct base path for the symlink tree.
+    const std::optional<std::string> runfiles_dir = get_env_variable("RUNFILES_DIR");
+    const std::optional<std::string> test_workspace = get_env_variable("TEST_WORKSPACE");
+    if (runfiles_dir && test_workspace) {
+      return std::list<std::string>{std::filesystem::path(*runfiles_dir) / *test_workspace};
+    }
+    
+    // If we get here then we are likely in a run context. In this case there will be no
+    // environment variable. The only clue is the presence of a MANIFEST file at the path
+    // of the executable path plus .runfiles/MANIFEST.
+    const std::optional<std::string> executable_path = get_executable_path();
+    if (executable_path) {
+      const std::filesystem::path runfiles_path(*executable_path + ".runfiles");
+      if (std::filesystem::exists(runfiles_path / "MANIFEST")) {
+        return std::list<std::string>{*executable_path + ".runfiles/_main"};
+      }
+    }
+    
+    // If we get here it means that we don't have an AMENT_PREFIX_PATH and we cant work out
+    // how to construct one from the Bazel context.
+    throw std::runtime_error("Could not calculate AMENT_PREFIX_PATH");
   }
 
   // split at token into separate paths
   std::list<std::string> paths;
-  std::stringstream ss(ament_prefix_path);
+  std::stringstream ss(*ament_prefix_path);
   std::string tok;
 #ifndef _WIN32
   char delim = ':';